<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从零开始移植TinyUSB协议栈 | MM32 Technical Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="简介本文将基于 Mini-F5277-OB 开发板，讲解从零开始移植Tiniy USB协议栈。 Mini-F5277-OB 开发板介绍 Mini-F5277-OB 开发板，搭载了MM32F5270系列中 MM32F5277E7PV 型号的MCU，为32位 Arm China STAR-MC1 架构，内置 256KB Flash，192KB SRAM，并带有USB全速设备控制器，支持 12Mbps">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始移植TinyUSB协议栈">
<meta property="og:url" content="http://example.com/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/index.html">
<meta property="og:site_name" content="MM32 Technical Notes">
<meta property="og:description" content="简介本文将基于 Mini-F5277-OB 开发板，讲解从零开始移植Tiniy USB协议栈。 Mini-F5277-OB 开发板介绍 Mini-F5277-OB 开发板，搭载了MM32F5270系列中 MM32F5277E7PV 型号的MCU，为32位 Arm China STAR-MC1 架构，内置 256KB Flash，192KB SRAM，并带有USB全速设备控制器，支持 12Mbps">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.mindmotion.com.cn/uploadfiles/2023/09/Mini-F5277-OB.png?TWluaS1GNTI3Ny1PQi5wbmc=">
<meta property="og:image" content="http://example.com/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/figure_representation_of_the_tinyusb_stack.svg">
<meta property="article:published_time" content="2024-01-15T03:44:40.000Z">
<meta property="article:modified_time" content="2024-01-17T08:22:54.602Z">
<meta property="article:author" content="Allen Ma">
<meta property="article:tag" content="TinyUSB">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mindmotion.com.cn/uploadfiles/2023/09/Mini-F5277-OB.png?TWluaS1GNTI3Ny1PQi5wbmc=">
  
    <link rel="alternate" href="/atom.xml" title="MM32 Technical Notes" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MM32 Technical Notes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这是一个 MM32 技术文档博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从零开始移植TinyUSB协议栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2024-01-15T03:44:40.000Z" itemprop="datePublished">2024-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从零开始移植TinyUSB协议栈
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将基于 Mini-F5277-OB 开发板，讲解从零开始移植Tiniy USB协议栈。</p>
<p><strong>Mini-F5277-OB 开发板介绍</strong></p>
<p>Mini-F5277-OB 开发板，搭载了MM32F5270系列中 MM32F5277E7PV 型号的MCU，为32位 Arm China STAR-MC1 架构，内置 256KB Flash，192KB SRAM，并带有USB全速设备控制器，支持 12Mbps 的传输速率。在配置为 USB Host 模式下支持 12Mbps 的全速传输和 1.5 Mbps 的低速传输速率。其中 USB_FS 控制器内置 USB 全速 PHY。</p>
<p><img src="https://www.mindmotion.com.cn/uploadfiles/2023/09/Mini-F5277-OB.png?TWluaS1GNTI3Ny1PQi5wbmc=" alt="Mini-F5277-OB"></p>
<p><strong>TinyUSB 协议栈介绍</strong></p>
<p>TinyUSB 是一个应用于嵌入式系统的开源跨平台 USB Host &#x2F; Device 协议栈，其优点为：MIT 开源协议，不用担心版权问题;内存安全（没有动态内存分配）;线程安全（所有中断事件都会放在非中断函数中处理）。</p>
<p>如下图所示，为TinyUSB协议栈结构框图：</p>
<p><img src="figure_representation_of_the_tinyusb_stack.svg"></p>
<center> 图x TinyUSB 协议栈框图 </center>

<p>由上图可知，TinyUSB协议栈中的Host 与 Device 是相互独立的两个协议。</p>
<p>TinyUSB 协议栈中的 Device 协议应用较为广泛，支持的 USB 类也十分丰富：</p>
<ul>
<li>Audio Class 2.0 (UAC2)</li>
<li>Bluetooth Host Controller Interface (BTH HCI)</li>
<li>Communication Class (CDC)</li>
<li>Device Firmware Update (DFU): DFU mode (WIP) and Runtinme</li>
<li>Human Interface Device (HID): Generic (In &amp; Out), Keyboard, Mouse, Gamepad etc …</li>
<li>Mass Storage Class (MSC): with multiple LUNs</li>
<li>Musical Instrument Digital Interface (MIDI)</li>
<li>Network with RNDIS, CDC-ECM (work in progress)</li>
<li>USB Test and Measurement Class (USBTMC)</li>
<li>Vendor-specific class support with generic In &amp; Out endpoints. Can be used with MS OS 2.0 compatible descriptor to load winUSB driver without INF file.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/WICG/webusb">WebUSB</a> with vendor-specific class</li>
</ul>
<p>而 Host 支持的类，就只有两个了，不过对于 MCU 的这种中小型资源的应用而言，以下两个类足够满足大部分需求了：</p>
<ul>
<li>Human Interface Device (HID): Keyboard, Mouse, Generic</li>
<li>Mass Storage Class (MSC)</li>
</ul>
<h2 id="添加TinyUSB协议栈"><a href="#添加TinyUSB协议栈" class="headerlink" title="添加TinyUSB协议栈"></a>添加TinyUSB协议栈</h2><p>TinyUSB协议栈源码下载地址：<code>https://github.com/hathach/tinyusb/releases/tag/0.16.0 </code></p>
<p>本次移植是基于截止目前最新版本的 TinyUSB V0.16.0 进行移植，这里我们用到了软件包 <code>tinyusb\src</code> 作为协议栈源码和 <code>tinyusb\examples</code> 文件夹中USB 样例代码。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── docs            # Documentation</span><br><span class="line">├── examples        # Examples with make and cmake build system</span><br><span class="line">├── hw</span><br><span class="line">│   ├── bsp         # Supported boards source files</span><br><span class="line">│   └── mcu         # Low level mcu core &amp; peripheral drivers</span><br><span class="line">├── lib             # Sources from 3rd party such as freeRTOS, fatfs ...</span><br><span class="line">├── src             # All sources files for TinyUSB stack itself.</span><br><span class="line">├── test            # Tests: unit test, fuzzing, hardware test</span><br><span class="line">└── tools           # Files used internally</span><br></pre></td></tr></table></figure>

<h2 id="配置USB-Device接口"><a href="#配置USB-Device接口" class="headerlink" title="配置USB Device接口"></a>配置USB Device接口</h2><p>USB Device移植接口在<code>tud_dcd_port.c</code>文件中实现，主要分为如下步骤：</p>
<ul>
<li>SETUP 包的接收</li>
<li>设置地址</li>
<li>接口适配</li>
<li>中断处理</li>
</ul>
<h3 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h3><p>为了适配 TinyUSB Device，在适配层一共设置如下全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* OTG_FS BufferDescriptorTable Buffer. */</span><br><span class="line">static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = &#123;0u&#125;; /*usb_bufdesp_table */</span><br><span class="line">static uint8_t usb_ep0_buf[CFG_TUD_ENDPOINT0_SIZE] = &#123;0u&#125;; /*usb_recv_buff. */</span><br><span class="line">static uint8_t usb_setup_buf[8u] = &#123;0u&#125;; /* usb_setup_buff. */</span><br><span class="line">static uint8_t usb_device_addr = 0u; /* usb_device_addr. */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t * xfer_buf;</span><br><span class="line">    uint32_t max_packet_size; /* EndPoint max packet size. */</span><br><span class="line">    uint32_t length; /* EndPoint xfer data length. */</span><br><span class="line">    uint32_t remaining; /* EndPoint xfer data remaining. */</span><br><span class="line">    bool odd_even; /* EndPoint BD OddEven status. */</span><br><span class="line">    bool data_n; /* next packet is DATA0 or DATA1. */</span><br><span class="line">    bool xfer_done;</span><br><span class="line">&#125; USB_EndPointManage_Type;</span><br><span class="line">static USB_EndPointManage_Type usb_epmng_tbl[16u][2u] = &#123;0u&#125;; /* EndPointManage Table. */</span><br></pre></td></tr></table></figure>

<p>在<code>tud_dcd_port.c</code> 文件中定义USB 数据缓冲区（在USB驱动中定义USB_BufDespTable_Type结构体类型），并在USB驱动初始化和USB协议栈任务处理时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static __ALIGNED(512u) USB_BufDespTable_Type usb_bd_tbl = &#123;0u&#125;; /* usb_bufdesp_table */</span><br></pre></td></tr></table></figure>

<h3 id="USB-端点管理"><a href="#USB-端点管理" class="headerlink" title="USB 端点管理"></a>USB 端点管理</h3><p>在<code>tud_dcd_port.c</code>文件中定义<code>USB_EndPointManage_Type</code>结构体类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> * xfer_buf;</span><br><span class="line">    <span class="type">uint32_t</span> max_packet_size;   <span class="comment">/* EndPoint max packet size. */</span></span><br><span class="line">    <span class="type">uint32_t</span> length;            <span class="comment">/* EndPoint xfer data length. */</span></span><br><span class="line">    <span class="type">uint32_t</span> remaining;         <span class="comment">/* EndPoint xfer data remaining. */</span></span><br><span class="line">    <span class="type">bool</span>  odd_even;          <span class="comment">/* EndPoint BD OddEven status. */</span></span><br><span class="line">    <span class="type">bool</span>  data_n;            <span class="comment">/* next packet is DATA0 or DATA1. */</span></span><br><span class="line">    <span class="type">bool</span>  xfer_done;</span><br><span class="line">&#125; USB_EndPointManage_Type;</span><br></pre></td></tr></table></figure>

<h3 id="USB-驱动使能"><a href="#USB-驱动使能" class="headerlink" title="USB 驱动使能"></a>USB 驱动使能</h3><p>在<code>tud_dcd_port.c</code>中的<code>dcd_init()</code>函数实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize controller to device mode</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dcd_init</span>       <span class="params">(<span class="type">uint8_t</span> rhport)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>) rhport;</span><br><span class="line">    USB_Device_Init_Type init = &#123;<span class="number">0u</span>&#125;;</span><br><span class="line">    init.BufDespTable_Addr = (<span class="type">uint32_t</span>)&amp;usb_bd_tbl;</span><br><span class="line">    USB_InitDevice(BOARD_USB_PORT, &amp;init);</span><br><span class="line">    USB_Enable(BOARD_USB_PORT, <span class="literal">true</span>);</span><br><span class="line">    NVIC_ClearPendingIRQ(BOARD_USB_IRQn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB-Device-中断"><a href="#USB-Device-中断" class="headerlink" title="USB Device 中断"></a>USB Device 中断</h3><p>在<code>tud_dcd_port.c</code>中的<code>dcd_int_enable()</code>和<code>dcd_int_disable()</code>函数实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Enable device interrupt</span><br><span class="line">void dcd_int_enable (uint8_t rhport)</span><br><span class="line">&#123;</span><br><span class="line">    (void) rhport;</span><br><span class="line">    USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_RESET | USB_INT_TOKENDONE</span><br><span class="line">                                            | USB_INT_SLEEP</span><br><span class="line">                                            | USB_INT_RESUME</span><br><span class="line">                                            | USB_INT_STALL</span><br><span class="line">                                            | USB_INT_SOFTOK, true); /* enable interrupts*/</span><br><span class="line">    NVIC_SetPriority(BOARD_USB_IRQn, 3u);</span><br><span class="line">    NVIC_EnableIRQ(BOARD_USB_IRQn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置USB-Host接口"><a href="#配置USB-Host接口" class="headerlink" title="配置USB Host接口"></a>配置USB Host接口</h2><p>MM32G5330 USB 支持 Host 功能，TinyUSB 协议栈中也包含了 Host 部分，在适配 Host 过程中，使用到了双向队列和数据库的概念。USB Host移植接口在<code>tuh_dcd_port.c</code>文件中实现，主要分为如下步骤：</p>
<ul>
<li>双向队列实现</li>
<li>数据库实现</li>
<li>接口实现</li>
<li>中断处理</li>
</ul>
<h3 id="双向队列实现"><a href="#双向队列实现" class="headerlink" title="双向队列实现"></a>双向队列实现</h3><p>USB 总线会像多个端点传输不同的内容，但 USB 总线只有一条，因此需要将传输任务放在一个队列中，按照队列的顺序传输数据 ；在传输过程中，可能会有分段传输，传输失败等情况，可能要将传输任务重新放在队列的头部，而不是末尾，因此，这个队列不仅能将传输任务放在队列尾部，也能将传输任务放在头部，就像堆栈那样，因此，需要实现一个双向队列。同普通的队列一样，双向队列需要一个队列buffer，以及管理队列 buffer 的字段，然后每次读写队列时，不能直接操作这个 buffer，而是只能使用给定的 push 和 pop 方法操作。实现操作如下：</p>
<p><strong>buffer 和管理字段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* xfer task deque node. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">......</span><br><span class="line">&#125; <span class="type">xfer_task_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* xfer task deque support. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">xfer_task_node_t</span> xfer_task_deque[TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE] =&#123;<span class="number">0u</span>&#125;; <span class="comment">/* xfer task deque buf. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> xfer_task_head = <span class="number">0u</span>; <span class="comment">/* record deque head. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> xfer_task_tail = <span class="number">0u</span>; <span class="comment">/* record deque tail. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> xfer_task_cnt = <span class="number">0u</span>; <span class="comment">/* record xfer task num. */</span></span><br></pre></td></tr></table></figure>

<p><strong>操作函数：</strong></p>
<p>从头部 pop，从尾部 push：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get deque head node &amp; delete the node in deque. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">xfer_task_pop_head</span><span class="params">(<span class="type">xfer_task_node_t</span> * task)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0u</span> == xfer_task_cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* no xfer_task. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* pop head: read head, head--, cnt--. */</span></span><br><span class="line"><span class="built_in">memcpy</span>(task, &amp;xfer_task_deque[xfer_task_head],</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">xfer_task_node_t</span>)); <span class="comment">/* read head. */</span></span><br><span class="line"><span class="keyword">if</span> (xfer_task_head == <span class="number">0u</span>) <span class="comment">/* head--. */</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_head = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - <span class="number">1u</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_head--;</span><br><span class="line">&#125;</span><br><span class="line">xfer_task_cnt--; <span class="comment">/* cnt--. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* put node in deque tail. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">xfer_task_push_tail</span><span class="params">(<span class="type">xfer_task_node_t</span> * task)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* queue full. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* push tail: write tail, tail--, cnt++ */</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;xfer_task_deque[xfer_task_tail], task,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">xfer_task_node_t</span>)); <span class="comment">/* write tail. */</span></span><br><span class="line"><span class="keyword">if</span> (xfer_task_tail == <span class="number">0u</span>) <span class="comment">/* head++. */</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_tail = TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - <span class="number">1u</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_tail--;</span><br><span class="line">&#125;</span><br><span class="line">xfer_task_cnt++;<span class="comment">/* cnt++. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的两个方法，这就是一个普通的单项队列，英文叫做 queue，既然是双向队列，就需要在这个基础上实现从头部 push 的功能，至于尾部 pop 由于在适配过程中没有使用，不再实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* put node in deque head. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">xfer_task_push_head</span><span class="params">(<span class="type">xfer_task_node_t</span> * task)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE == xfer_task_cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* queue full. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* push head: head++, write head, cnt++ */</span></span><br><span class="line"><span class="keyword">if</span> (xfer_task_head == TUH_HCD_PORT_XFER_TASK_DEQUE_SIZE - <span class="number">1u</span>) <span class="comment">/* head++.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_head = <span class="number">0u</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">xfer_task_head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;xfer_task_deque[xfer_task_head], task,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">xfer_task_node_t</span>)); <span class="comment">/* write tail. */</span></span><br><span class="line">xfer_task_cnt++;<span class="comment">/* cnt++. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要清空双向队列的内容时，或初始化双向队列时，可使用下列方法操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset the deque, delete all node. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xfer_task_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xfer_task_head = <span class="number">0u</span>;</span><br><span class="line">    xfer_task_tail = <span class="number">0u</span>;</span><br><span class="line">    xfer_task_cnt = <span class="number">0u</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><p>所谓数据库，只是用于存放各设备各端点信息的地方。每次发送传输数据的时候，需要知道端点的buffer 大小等信息，所以需要在数据库中查询端点信息。需要支持inset操作，delete操作，update 操作和select操作，即增删改查：</p>
<p>insert 操作，指将一条数据条目插入到数据表中，该条目是数据表中原来没有的内容</p>
<p>delete 操作，指删除数据条目或数据表</p>
<p>update 操作，指将一条数据条目更新到原有的条目中，主要更新原有条目的字段内容</p>
<p>select 操作，根据关键字查找数据表中的条目</p>
<p><strong>buffer 和管理字段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* endpoint status table. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ep_status_t</span> ep_tbl[TUH_HCD_PORT_MAX_EP_NUM]; <span class="comment">/* the table that record the ep_status. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> ep_count = <span class="number">0u</span>; <span class="comment">/* record the how many endpoint status in ep_tbl[]. */</span></span><br></pre></td></tr></table></figure>

<p><strong>insert &amp; update 操作：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* add new or modify endpoint status. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ep_set_status</span><span class="params">(<span class="type">ep_status_t</span> * status)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">ep_status_t</span> * ep_status = ep_get_status(status-&gt;dev_ep_addr);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == ep_status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ep_count == TUH_HCD_PORT_MAX_EP_NUM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">ep_status = &amp;ep_tbl[ep_count];</span><br><span class="line">ep_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(ep_status, status, <span class="keyword">sizeof</span>(<span class="type">ep_status_t</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>select 操作：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get endpoint status. */</span></span><br><span class="line"><span class="type">ep_status_t</span> * <span class="title function_">ep_get_status</span><span class="params">(<span class="type">uint32_t</span> dev_ep_addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">ep_status_t</span> * ep_status = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0u</span>; i &lt; ep_count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dev_ep_addr == ep_tbl[i].dev_ep_addr)</span><br><span class="line">&#123;</span><br><span class="line">ep_status = &amp;ep_tbl[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ep_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的操作，当 USB Device 拔掉的时候，数据库需要进行复位，相当于执行 delete 操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear all endpoint status. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ep_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ep_count = <span class="number">0u</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是在适配 TinyUSB Host 协议栈之前要做的一些事情，接下来开始讲述如何适配 TinyUSB：</p>
<h3 id="USB-缓冲描述表定义"><a href="#USB-缓冲描述表定义" class="headerlink" title="USB 缓冲描述表定义"></a>USB 缓冲描述表定义</h3><p>在<code>tuh_dcd_port.c</code> 文件中定义USB 数据缓冲区（在USB驱动中定义USB_BufDespTable_Type结构体类型），在USB驱动初始化和USB协议栈任务处理时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* usb buf descriptor table. */</span><br><span class="line">__attribute__ ((aligned(512))) static USB_BufDespTable_Type usb_bdt = &#123;0u&#125;;</span><br><span class="line"></span><br><span class="line">/* speed status. */</span><br><span class="line">volatile static tusb_speed_t device_speed = TUSB_SPEED_FULL;</span><br><span class="line"></span><br><span class="line">/* xfer_buf. */</span><br><span class="line">__attribute__ ((aligned(4))) static uint8_t usb_xfer_buf[TUH_HCD_PORT_XFER_BUF_SIZE] = &#123;0u&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="USB-端点管理-1"><a href="#USB-端点管理-1" class="headerlink" title="USB 端点管理"></a>USB 端点管理</h3><p>在<code>tud_dcd_port.c</code>文件中定义<code>USB_EndPointManage_Type</code>结构体类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> * xfer_buf;</span><br><span class="line">    <span class="type">uint32_t</span> max_packet_size;   <span class="comment">/* EndPoint max packet size. */</span></span><br><span class="line">    <span class="type">uint32_t</span> length;            <span class="comment">/* EndPoint xfer data length. */</span></span><br><span class="line">    <span class="type">uint32_t</span> remaining;         <span class="comment">/* EndPoint xfer data remaining. */</span></span><br><span class="line">    <span class="type">bool</span>  odd_even;          <span class="comment">/* EndPoint BD OddEven status. */</span></span><br><span class="line">    <span class="type">bool</span>  data_n;            <span class="comment">/* next packet is DATA0 or DATA1. */</span></span><br><span class="line">    <span class="type">bool</span>  xfer_done;</span><br><span class="line">&#125; USB_EndPointManage_Type;</span><br></pre></td></tr></table></figure>

<h3 id="USB驱动使能"><a href="#USB驱动使能" class="headerlink" title="USB驱动使能"></a>USB驱动使能</h3><p>在<code>tuh_dcd_port.c</code>中的<code>dcd_init()</code>函数实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize controller to host mode. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hcd_init</span><span class="params">(<span class="type">uint8_t</span> rhport)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)rhport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init usb host module. */</span></span><br><span class="line">    USB_Host_Init_Type usb_init;</span><br><span class="line">    usb_init.BufDespTable_Addr = (<span class="type">uint32_t</span>)(&amp;usb_bdt);</span><br><span class="line">    usb_init.SofThreshold      = BOARD_USB_SOFTHRESHOLD;</span><br><span class="line">    usb_init.NakRetry          = <span class="literal">false</span>;</span><br><span class="line">    USB_InitHost(BOARD_USB_PORT, &amp;usb_init);</span><br><span class="line"></span><br><span class="line">    USB_EnableOddEvenReset(BOARD_USB_PORT, <span class="literal">true</span>); <span class="comment">/* only use even buf desp, this example will not usb odd buf desp xfer data. */</span></span><br><span class="line">    USB_SetDeviceAddr(BOARD_USB_PORT, <span class="number">0x00</span>); <span class="comment">/* set usb addr is 0x00, to xfer data when device attached. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable interrupt, but not use NVIC_EnableIRQ(). */</span></span><br><span class="line">    NVIC_ClearPendingIRQ(BOARD_USB_IRQn);</span><br><span class="line">    USB_EnableInterrupts(BOARD_USB_PORT, USB_INT_ATTACH | USB_INT_ERROR, <span class="literal">true</span>);</span><br><span class="line">    USB_EnableErrInterrupts(BOARD_USB_PORT, <span class="number">0xFF</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="USB-Host中断"><a href="#USB-Host中断" class="headerlink" title="USB Host中断"></a>USB Host中断</h3><p>在<code>tuh_dcd_port.c</code>中的<code>hcd_init()</code>函数中已经实现。</p>
<p>相较于 USB Device 中断的使能，USB Host 中断只开启了 <code>USB_INT_ATTACH</code>中断和<code>USB_INT_ERROR</code>中断。</p>
<h3 id="TinyUSB协议栈样例介绍"><a href="#TinyUSB协议栈样例介绍" class="headerlink" title="TinyUSB协议栈样例介绍"></a>TinyUSB协议栈样例介绍</h3><p>TinyUSB 协议栈自身提供了丰富的 USB Device样例和 USB Host 样例，我们只需要通过使用配置好的 USB Device接口和 USB Host 接口，和 TinyUSB 协议栈提供协议栈源文件和样例代码，按照不同的样例重新建立对应的工程便可实现 TinyUSB 提供的USB Device样例和 USB Host 样例。</p>
<ul>
<li>LibTinyUSB 中已实现多个 tinyusb 的样例，样例全部来自 tinyusb 官方实现的代码，但 LibTinyUSB 中的 examples 为了减小 size，删除了 examples 文件夹，可到 tinyusb 官网拉取最新的 git 仓库，获取 examples。</li>
<li>将 examples 的某一个样例中的源代码复制，替换 LibTinyUSB 样例中的 app 代码，即可实现新的 app 代码。</li>
</ul>
<h3 id="board-test"><a href="#board-test" class="headerlink" title="board_test"></a>board_test</h3><p>该样例为TinyUSB提供的基本板载样例，用于测试验证MCU和开发板能否正常运行。</p>
<h3 id="tud-cdc-dual-ports"><a href="#tud-cdc-dual-ports" class="headerlink" title="tud_cdc_dual_ports"></a>tud_cdc_dual_ports</h3><p>该样例为TinyUSB提供的USB Device双串口样例，用于演示USB Device枚举双串口功能。</p>
<h3 id="tud-cdc-msc"><a href="#tud-cdc-msc" class="headerlink" title="tud_cdc_msc"></a>tud_cdc_msc</h3><p>该样例为TinyUSB提供的USB Device大容量存储设备样例，用于演示USB Device枚举大容量存储设备功能。</p>
<h3 id="tud-hid-composite"><a href="#tud-hid-composite" class="headerlink" title="tud_hid_composite"></a>tud_hid_composite</h3><p>该样例为TinyUSB提供的USB Device HID样例，用于演示USB Device枚举鼠标键盘设备功能。</p>
<h3 id="tud-msc-dual-lun"><a href="#tud-msc-dual-lun" class="headerlink" title="tud_msc_dual_lun"></a>tud_msc_dual_lun</h3><p>该样例为TinyUSB提供的USB Device大容量存储设备样例，用于演示USB Device枚举两个大容量存储设备功能。</p>
<h3 id="tud-video-capture"><a href="#tud-video-capture" class="headerlink" title="tud_video_capture"></a>tud_video_capture</h3><p>该样例为TinyUSB提供的USB Device摄像头样例，用于演示USB Device枚举一个摄像头设备功能。</p>
<h3 id="tud-webusb-serial"><a href="#tud-webusb-serial" class="headerlink" title="tud_webusb_serial"></a>tud_webusb_serial</h3><p>该样例为TinyUSB提供的USB Device的Vender样例，用于演示USB Device枚举网页USB串口设备功能。</p>
<h3 id="tuh-bare-api"><a href="#tuh-bare-api" class="headerlink" title="tuh_bare_api"></a>tuh_bare_api</h3><p>该样例为TinyUSB提供的USB Host的基本API使用演示样例，用于演示USB Host读取FATFS 格式的存储设备（如：U盘）功能。</p>
<h3 id="tuh-cdc-msc-hid"><a href="#tuh-cdc-msc-hid" class="headerlink" title="tuh_cdc_msc_hid"></a>tuh_cdc_msc_hid</h3><p>该样例为TinyUSB提供的USB Host读取大容量存储设演示样例，用于演示USB Host读取FATFS 格式的存储设备（如：U盘）功能。</p>
<h3 id="tuh-hid-controller"><a href="#tuh-hid-controller" class="headerlink" title="tuh_hid_controller"></a>tuh_hid_controller</h3><p>该样例为TinyUSB提供的USB Host控制器样例，用于演示USB Host读取游戏手柄信息（这里指定了索尼PS4游戏手柄）功能。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>USB 使用<code>12.000MHz</code>高精度晶振，需在G5330工程中开启全局宏定义 <code>CUSTOM_HSE_VAL</code> 来开启。</p>
<p>启用 USB Host 时，需要通过电源开关芯片（如：SY6280AAC）来控制对USB Device 的供电，因 Mini-G5330 开发板未提供 USB A 接口和电源开关芯片，这里可以将 D+(PA11)、D-(PA12) 和 EN(PC13)引脚外接至外部的 USB A 外围电路中进行测试验证。</p>
<h3 id="SIE"><a href="#SIE" class="headerlink" title="SIE"></a>SIE</h3><p>SIE 在 USB 驱动中是指 Serial Interface Engine，即串行接口引擎。它是 USB 外设中最关键的硬件组成部分之一。SIE 负责处理与 USB 通信协议相关的所有底层操作，包括但不限于以下功能：</p>
<ol>
<li>速度识别：识别设备的传输速度（低速、全速、高速）。</li>
<li>包解析和构造：解析接收到的 USB 数据包，并构造要发送的数据包。</li>
<li>NRZI 编&#x2F;译码和填充位操作：NRZI （Non-Return-to-Zero Inverted）是一种信号编码方式，SIE 能够进行 NRZI 编码和解码，以及添加和去除数据包中的填充位以保持时钟同步。</li>
<li>与 USB 总线的电气接口：包括 UTMI（Universal Transceiver Macrocell Interface）或其他类似的物理层接口，用于实现与 USB 总线的电气连接和信号传输。</li>
</ol>
<h3 id="OTA"><a href="#OTA" class="headerlink" title="OTA"></a>OTA</h3><p>G5330(MM3350)不支持 dual-role device OTG 双角色设备模式</p>
<p>USB OTG（On-The-Go）的双角色功能是指设备能够同时扮演主机（Host）和外设（Peripheral）的角色。在传统的USB系统中，通常有一个设备作为主机，负责控制和管理数据传输，而其他设备则是外设，只能被动响应主机的请求。</p>
<p>然而，在USB OTG中，双角色设备（Dual-Role Device，DRD）的设计允许一个设备在不同的时间或在需要的时候切换其角色。这意味着这样的设备既可以作为主机来发起数据传输，例如从一个USB闪存驱动器读取数据，也可以作为外设与其他设备连接，如被另一台设备（可能是另一台OTG设备或者传统的主机）访问或充电。</p>
<p>这种灵活性使得USB OTG双角色设备在移动设备和便携式设备中特别有用，比如智能手机和平板电脑，这些设备可能需要与其他设备交换数据，或者在没有传统主机（如电脑）的情况下直接进行数据传输和供电操作。通过USB OTG的双角色支持，设备之间的交互变得更加便捷和多样化。</p>
<p>支持主机协商协议（HNP）和会话请求协议（SRP）是USB On-The-Go（OTG）规范中的两个关键特性。</p>
<ol>
<li>主机协商协议（HNP）： HNP允许USB OTG设备在操作过程中动态切换其角色，即从主机角色切换到外设角色，或者从外设角色切换到主机角色。这种切换是在设备之间直接进行的，无需人工干预。例如，当一个OTG设备正在作为主机与另一个设备通信，但随后希望被连接到一个更强大的主机（如电脑）时，它可以使用HNP请求将主机角色转移给新连接的设备。</li>
<li>会话请求协议（SRP）： SRP是USB OTG中的另一个重要特性，它允许无主电源（即自身不供电的设备，通常称为A设备）启动与有主电源设备（通常称为B设备）的通信会话。在传统的USB系统中，数据传输总是由主机发起。但在USB OTG中，由于设备可以动态切换角色，因此需要一种机制让无主电源设备能够启动通信。SRP就是用于实现这一目标的协议，它允许无主电源设备通过向有主电源设备发送一个会话请求来启动数据传输。</li>
</ol>
<p>总的来说，HNP和SRP都是为了增强USB OTG设备的灵活性和互操作性，使得设备能够根据需要动态调整其角色和行为，从而在各种不同的使用场景下提供更好的用户体验。</p>
<h3 id="USB的SE0信号"><a href="#USB的SE0信号" class="headerlink" title="USB的SE0信号"></a>USB的SE0信号</h3><p>在USB（Universal Serial Bus）协议中，SE0（Single-Ended Zero）信号是一种特殊的信号状态，它表示数据线D+和D-上的电平都为逻辑0（低电平）。</p>
<p>SE0信号在USB通信中扮演着重要的角色，主要用于错误检测、设备初始化和总线恢复等操作。它是确保USB总线稳定性和可靠性的关键部分。</p>
<h3 id="USB的JSTATE-信号"><a href="#USB的JSTATE-信号" class="headerlink" title="USB的JSTATE 信号"></a>USB的JSTATE 信号</h3><p>USB差分接收器接收到JSTATE信号时，它通常是作为设备枚举和速度检测过程的一部分，帮助主机正确识别和配置连接的USB设备。</p>
<h3 id="STALL-中断"><a href="#STALL-中断" class="headerlink" title="STALL 中断"></a>STALL 中断</h3><p>STALL中断是USB协议中一种重要的错误处理和通信机制，它允许设备向主机报告无法处理请求的情况，并促使主机采取相应的措施来解决问题。通过正确处理STALL中断，可以提高USB通信的可靠性和稳定性。</p>
<h3 id="RESUME中断"><a href="#RESUME中断" class="headerlink" title="RESUME中断"></a>RESUME中断</h3><p>RESUME中断是USB协议中一种重要的<strong>电源管理机制</strong>，它允许设备在暂停后重新启动数据传输，并确保主机能够正确地处理设备的恢复请求。通过有效管理RESUME中断，可以提高USB设备的能效和用户体验。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>USB 2.0 Specification：<a target="_blank" rel="noopener" href="https://usb.org/document-library/usb-20-specification">https://usb.org/document-library/usb-20-specification</a></li>
<li>TinyUSB 官网：<a target="_blank" rel="noopener" href="https://docs.tinyusb.org/en/latest/">https://docs.tinyusb.org/en/latest/</a></li>
<li>MM32F5270 UM：<a target="_blank" rel="noopener" href="https://mindmotion.com.cn/download/products/UM_MM32F5270_MM32F5280_SC.pdf">https://mindmotion.com.cn/download/products/UM_MM32F5270_MM32F5280_SC.pdf</a></li>
<li>MM32F0270 UM：<a target="_blank" rel="noopener" href="https://mindmotion.com.cn/download/products/UM_MM32F0270_SC.pdf">https://mindmotion.com.cn/download/products/UM_MM32F0270_SC.pdf</a></li>
<li>《圈圈教你玩 USB》，刘荣，北京航空航天大学出版社，ISBN: 9787811246001</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/" data-id="clrhimnlf0003o4v9b9z51be0" data-title="从零开始移植TinyUSB协议栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TinyUSB/" rel="tag">TinyUSB</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DLwIP%E5%8D%8F%E8%AE%AE%E6%A0%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          从零开始移植LwIP协议栈
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CANopenNode/" rel="tag">CANopenNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LwIP/" rel="tag">LwIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TinyUSB/" rel="tag">TinyUSB</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CANopenNode/" style="font-size: 10px;">CANopenNode</a> <a href="/tags/LwIP/" style="font-size: 10px;">LwIP</a> <a href="/tags/TinyUSB/" style="font-size: 10px;">TinyUSB</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植CANopenNode协议栈</a>
          </li>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DLwIP%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植LwIP协议栈</a>
          </li>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植TinyUSB协议栈</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Allen Ma<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>