<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从零开始移植CANopenNode协议栈 | MM32 Technical Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="基于MM32G5330移植CANopenNode协议栈引言基本的CAN总线外设驱动程序能够提供基本的操作硬件电路系统的服务，但在具体的应用系统中，更多是基于协议栈开发上层应用，而不是针对某个具体的芯片平台编写定制的应用程序。目前CANopen是工业自动化领域最常用的协议栈标准之一。对应地，有一些实现CANopen协议的开源软件包，例如CANopenNode、CAN Festival等。  CANo">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始移植CANopenNode协议栈">
<meta property="og:url" content="http://example.com/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/index.html">
<meta property="og:site_name" content="MM32 Technical Notes">
<meta property="og:description" content="基于MM32G5330移植CANopenNode协议栈引言基本的CAN总线外设驱动程序能够提供基本的操作硬件电路系统的服务，但在具体的应用系统中，更多是基于协议栈开发上层应用，而不是针对某个具体的芯片平台编写定制的应用程序。目前CANopen是工业自动化领域最常用的协议栈标准之一。对应地，有一些实现CANopen协议的开源软件包，例如CANopenNode、CAN Festival等。  CANo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/.com//CANopen-intro-basics-guide-dummies-tutorial.png">
<meta property="og:image" content="http://example.com/.com//OSI_Mode_For_CANopen.png">
<meta property="og:image" content="http://example.com/.com//01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/OSI_Mode_For_CANopen.png">
<meta property="og:image" content="http://example.com/.com//CANopen-Network-Model-Object-Dictionary-Communication-Application.svg">
<meta property="og:image" content="http://example.com/.com//ModeforCANopen.png">
<meta property="og:image" content="http://example.com/.com//CANopen-COB-ID-Message-Format-CAN-Frame.png">
<meta property="og:image" content="http://example.com/.com//CANopen-data-structural.png">
<meta property="og:image" content="http://example.com/.com//CANopen_BasicNetwork.png">
<meta property="og:image" content="http://example.com/.com//CANopen_ComplexesNetwork.png">
<meta property="og:image" content="http://example.com/.com//CANopenStatus.png">
<meta property="og:image" content="http://example.com/.com//components_canopen.png">
<meta property="og:image" content="http://example.com/.com//CANopenNode-example.png">
<meta property="og:image" content="http://example.com/.com//CANopenNode-drvTemp.png">
<meta property="og:image" content="http://example.com/.com//PCAN-View.png">
<meta property="og:image" content="http://example.com/.com//image-mcu&pc.png">
<meta property="og:image" content="http://example.com/.com//Stop-the-Node.png">
<meta property="og:image" content="http://example.com/.com//Start-the-Node.png">
<meta property="og:image" content="http://example.com/.com//Preoperaion-the-Node.png">
<meta property="og:image" content="http://example.com/.com//Reset--the-Node.png">
<meta property="og:image" content="http://example.com/.com//Reset-commu-the-Node.png">
<meta property="og:image" content="http://example.com/.com//Get-heartbeat.png">
<meta property="og:image" content="http://example.com/.com//Set-heartbeat.png">
<meta property="article:published_time" content="2024-01-15T07:33:10.000Z">
<meta property="article:modified_time" content="2024-01-16T02:51:07.562Z">
<meta property="article:author" content="Allen Ma">
<meta property="article:tag" content="CANopenNode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//CANopen-intro-basics-guide-dummies-tutorial.png">
  
    <link rel="alternate" href="/atom.xml" title="MM32 Technical Notes" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MM32 Technical Notes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这是一个 MM32 技术文档博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从零开始移植CANopenNode协议栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2024-01-15T07:33:10.000Z" itemprop="datePublished">2024-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从零开始移植CANopenNode协议栈
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基于MM32G5330移植CANopenNode协议栈"><a href="#基于MM32G5330移植CANopenNode协议栈" class="headerlink" title="基于MM32G5330移植CANopenNode协议栈"></a>基于MM32G5330移植CANopenNode协议栈</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>基本的CAN总线外设驱动程序能够提供基本的操作硬件电路系统的服务，但在具体的应用系统中，更多是基于协议栈开发上层应用，而不是针对某个具体的芯片平台编写定制的应用程序。目前CANopen是工业自动化领域最常用的协议栈标准之一。对应地，有一些实现CANopen协议的开源软件包，例如CANopenNode、CAN Festival等。</p>
<p><img src="/.com//CANopen-intro-basics-guide-dummies-tutorial.png" alt="CANopen-intro-basics-guide-dummies-tutorial"></p>
<h2 id="CANopen概述"><a href="#CANopen概述" class="headerlink" title="CANopen概述"></a>CANopen概述</h2><p><strong>CANopen 的诞生和作用</strong></p>
<p>CANopen 协议是在20世纪90年代末，由总部位于德国纽伦堡的CiA (CAN-in-Automation)组织(<a target="_blank" rel="noopener" href="http://www.can-cia.org)在cal/">http://www.can-cia.org)在CAL</a>(CAN Application Layer)的基础上发展而来。由于CANopen协议的创始人团队也是CAN-bus的创始人团队，此协议充分发挥了CAN-bus所具备的所有优势，特别是 CiA 组织的主席蔡豪格((Holger Zeltwanger)先生对于CANopen协议坚持开放、免费、非盈利的原则。一经推出便在欧洲得到了广泛的认可与应用。虽然CiA组织背后没有强大的财阀支撑，但时至今日已经成为全世界最为流行的CAN应用层协议。</p>
<p>CANopen主要提供了两个服务：第一个是提供了一个基于CAN的通信协议，可以将多个设备连接到一个总线；第二个是提供了一个用于设备管理的标准，可以将多个设备组织成一个系统，以实现远程监控和控制。目前，CANopen作为工业自动化领域最常用的标准之一，被广泛应用于汽车、航空航天、楼宇自动化等行业。 </p>
<p>如图x所示，CNAopen是一个基于CAN总线的上层协议，其中CAN涵盖了OSI模型的前两层：物理层和数据链路层，CANopen涵盖了后五层：网络层（寻址、路由）、传输层（端到端可靠性）、会话层（同步）、表现层（以标准方式编码的数据、数据表现）和应用层。应用层规定了CANopen设备是如何配置、传输和同步。</p>
<p><img src="/.com//OSI_Mode_For_CANopen.png" alt="OSI_Mode_For_CANopen"></p>
<center> 图x </center>

<img src="/.com//01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/OSI_Mode_For_CANopen.png" class title="This is an example image">


<p>  CANopen从应用端到CAN总线的结构如下图x所示：</p>
<ul>
<li>应用层(Application)<ul>
<li>用于实现各种应用对象</li>
</ul>
</li>
<li>对象字典(Object dictionary)<ul>
<li>用于描述CANopen节点设备的参数</li>
</ul>
</li>
<li>通信接口(Communication interface)<ul>
<li>定义了CANopen协议通信规则以及CAN控制器驱动之间对应关系</li>
</ul>
</li>
</ul>
<p><img src="/.com//CANopen-Network-Model-Object-Dictionary-Communication-Application.svg" alt="CANopen-Network-Model-Object-Dictionary-Communication-Application"></p>
<center> 图 x </center>




<p>在CANopen网络中，通常需要多个设备进行通信，在CANopen网络中用到了如下三种通信模型：</p>
<p><img src="/.com//ModeforCANopen.png" alt="3ModeOfCANopen"></p>
<ul>
<li>主机&#x2F;从机模型(Master&#x2F;Salve)<ul>
<li>一个节点(例如控制接口)充当应用程序主机控制器，从机(例如伺服电机)发送&#x2F;请求数据，一般在诊断或状态管理中使用。</li>
<li>通信样例：NMT主机与NMT从机的通信<ul>
<li>所有节点通信地位平等，运行时允许自行发送报文，但CANopen网络为了稳定可靠可控，都需要设置一个网络管理主机 NMT-Master。</li>
<li>NMT主机一般是CANopen网络中具备监控的PLC或者PC(当然也可以是一般的功能节点)，所以也成为CANopen主站。相对应的其他CANopen节点就是NMT从机(NMT-slaves)。</li>
</ul>
</li>
</ul>
</li>
<li>客户端&#x2F;服务端模型(Client&#x2F;Server)<ul>
<li>客户机向服务器发送数据请求，服务器进行响应。例如，当应用程序主机需要来自从机OD的数据时使用。</li>
<li>通信样例：SDO客户端与SDO服务端的通信<ul>
<li>发送节点需要指定接收节点的地址(Node-ID)回应CAN报文来确认已经接收，如果超时没有确认，则发送节点将会重新发送原报文。</li>
</ul>
</li>
</ul>
</li>
<li>生产者&#x2F;消费者模型(Producer&#x2F;Consumer)<ul>
<li>生产者节点向网络广播数据，而网络由使用者节点使用。生产者可以根据请求发送此数据，也可以不发送特定请求。</li>
<li>通信样例：心跳生产者与心跳消费者的通信<ul>
<li>单向发送传输，无需接收节点回应CAN报文来确认。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>CANopen的COB-ID</strong></p>
<ul>
<li>11位CAN ID在CANopen中被称为COB-ID，这11位COB-ID被分为两部分：前4位是功能码，后7位是(节点ID)，且7位的节点ID限制了CANopen网络上的设备数量为127个节点。</li>
</ul>
<p><img src="/.com//CANopen-COB-ID-Message-Format-CAN-Frame.png" alt="CANopen-COB-ID-Message-Format-CAN-Frame"></p>
<p><strong>CANopen的7种报文类型</strong></p>
<ul>
<li><p>NMT(Network Management)</p>
<ul>
<li>控制CANopen设备状态，用于网络管理。</li>
</ul>
</li>
<li><p>SYNC(Synchronization)</p>
<ul>
<li>SYNC 消息用于同步多个 CANopen 设备的输入感应和驱动——通常由应用程序 Master 触发。</li>
</ul>
</li>
<li><p>EMCY(Emergency)</p>
<ul>
<li>在设备发生错误(例如传感器故障)时使用的，发送设备内部错误代码。</li>
</ul>
</li>
<li><p>TIME</p>
<ul>
<li>用于分配网络时间，议采用广播方式，无需节点应答，CAN-ID 为 100h，数据长度为 6，数据为当前时刻与1984年1月1日0时的时间差。节点将此时间存储在对象字典1012h的索引中。</li>
</ul>
</li>
<li><p>PDO(Process Object)</p>
<ul>
<li>PDO服务用于在设备之间传输实时数据，例如测量数据(如位置数据)或命令数据(如扭矩请求)。</li>
</ul>
</li>
<li><p>SDO(Sever D Object)</p>
<ul>
<li>用于访问&#x2F;更改CANopen设备的对象字典中的值——例如，当应用程序主机需要更改CANopen设备的某些配置时。</li>
</ul>
</li>
<li><p>Heartbeat</p>
<ul>
<li>Heartbeat服务有两个用途: 提供“活动”消息和确认NMT命令。</li>
</ul>
</li>
</ul>
<p><strong>OD(Object Dictionary，对象字典)</strong></p>
<ul>
<li><p>什么是对象字典？</p>
<ul>
<li>对象字典是一个标准的数据结构，描述了CANopen节点的不同的对象参数特性。</li>
<li>每个CANopen节点都包含一个对象字典，使用ESD文件来记录节点参数。</li>
<li>Master节点可通过SDO(且只能通过SDO)来访问和配置Slave节点的对象字典。</li>
</ul>
</li>
<li><p>对象字典中每个对象的构成</p>
<ul>
<li>Index (索引)：16位对象的基地址，其范围在0x0000到0xFFFF之间。</li>
<li>Sub Index (子索引)：为了避免数据大量时无索引可分配，所以在某些索引下也定义了一个8位的索引值，其范围是0x00到0xFF 之间。</li>
<li>Object name (对象名称): 如：制造商设备名称。</li>
<li>Object type(目标类型):  变量、数组或记录。</li>
<li>Data type (数据类型):例如 字符串类型, UNSIGNED32类型UNSIGNED16类型。</li>
<li>Access (访问权限)：rw (read&#x2F;write), ro (read-only), wo (write-only)。</li>
<li>Default Value(默认值): </li>
<li>Category (类型)：指定此参数是否为强制&#x2F;可选(M&#x2F;O)。</li>
</ul>
<p>  <img src="/.com//CANopen-data-structural.png" alt="CANopen-data-structural"></p>
</li>
<li><p>EDS(The Electronic Data Sheet)</p>
<ul>
<li>在实际使用中，配置或管理复杂的 CANopen 网络将使用软件工具来完成，CiA 306标准定义了一个人类可读的且对机器友好的出厂文件格式即EDS格式文件，作为设备OD的“模板”。EDS文件通常由设备供应商提供，包含所有设备对象(但不包含参数值)的信息。简而言之，EDS是由CANopen设备厂商提供的不带参数的设备OD模板。</li>
</ul>
</li>
<li><p>对象字典编辑器</p>
<ul>
<li>对象字典编辑器是用于CANopen对象字典、设备信息等的GUI编辑器，可将 EDS 格式文件导入，通过编辑器编辑赋值后导出成 CANopen对象字典的C源代码文件。导出的在两个源代码文件CO_OD.c和CO_OD.h文件就是我们最终在软件开发时需要的对象字典源文件。</li>
</ul>
</li>
</ul>
<p><strong>CANopen主站和从站</strong></p>
<p>具有网络管理（Network Management：简称NMT）主机功能的设备通常被称为CANopen主站设备，通常也具有服务数据（Service Date Object：简称SDO）客户端功能。反之具有网络管理（NMT）从机功能的设备通常被称为CANopen从站设备，且其必须具备有服务数据服务器功能。这样CANopen主站设备就可以控制从站以及读写CANopen从站设备的对象字典。</p>
<ul>
<li>CANopen从站特性<ul>
<li>CANopen从站在CANopen网络中拥有唯一的节点地址，并且能独立完成特定的功能，例如数据采集、电机控制等等。对实时性要求高的数据，通常通过实时数据过程（Process Data Object：简称PDO）进行传输，因此CANopen从站应当支持一定数量的PDO传输功能。根据CANopen协议DS301 V4.02的定义，每个从站都预定义了4个TPDO（Transmit Process Data Object：简称TPDO）和4个RPDO（Receive Process Data Object），另外从站也应具有节点&#x2F;寿命保护或心跳报文以及生产紧急报文等功能。每个CANopen从站都应有一个对象字典，描述了从站所具有的应用参数和通信参数。</li>
</ul>
</li>
<li>CANopen主站特性<ul>
<li>CANopen主站在网络所起的作用有别于CANopen从站，通常CANopen主站在网络中负责网络管理、从站参数配置以及从站数据的处理，其并不一定具有特定的功能，但也有自己的对象字典和唯一的节点地址，一般是CANopen网络中具备监控的PLC或者PC(当然也可以是一般的功能节点)。</li>
</ul>
</li>
</ul>
<p><strong>CANopen网络组建</strong></p>
<p>由于CANopen是基于CAN总线的一种应用层协议，因此其网络组建与CAN总线一致，典型的总线型结构，从站和主站都挂接在该总线上即可，在一个CANopen网络中只能有一个主站设备和若干个从站设备同时工作。CANopen网络布线时选用带屏蔽双绞线，提高总线抗干扰能力。表 x 所示为CAN通信比特率与总线长度的关系。</p>
<center> 表 x </center>




<table>
<thead>
<tr>
<th><strong>Bit rate</strong></th>
<th>Bus length</th>
</tr>
</thead>
<tbody><tr>
<td>1 Mbit&#x2F;s</td>
<td>25 m</td>
</tr>
<tr>
<td>800 kbit&#x2F;s</td>
<td>50 m</td>
</tr>
<tr>
<td>500 kbit&#x2F;s</td>
<td>100 m</td>
</tr>
<tr>
<td>250 kbit&#x2F;s</td>
<td>250 m</td>
</tr>
<tr>
<td>125 kbit&#x2F;s</td>
<td>500 m</td>
</tr>
<tr>
<td>50 kbit&#x2F;s</td>
<td>1.000 m</td>
</tr>
<tr>
<td>20 kbit&#x2F;s</td>
<td>2.500 m</td>
</tr>
<tr>
<td>10 kbit&#x2F;s</td>
<td>5.000 m</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>总线长度的估计是基于CANopen CiA 301 规范建议的采样点位置。</li>
<li>总线长度的估计是基于5 ns&#x2F;m的传播延迟。此外，还需要考虑所用的CAN控制器、CAN收发器和光耦合器的延迟时间。</li>
</ul>
<p>如图x所示为CANopen网络的基本结构，在该网络中有一个CANopen主站，负责管理网络中的所有从站，每个设备都有一个独立的节点地址（NodeID）。从站与从站之间也能建立通信，通常需要事先对各个从站进行配置，使各个从站之间能够建立起独立的PDO通信。</p>
<p><img src="/.com//CANopen_BasicNetwork.png" alt="image-20230224143027633"></p>
<center>图x </center>




<p>图x所示为带有网关设备的CANopen网络，与基本的CANopen网络相比，该网络中增加了一个CANopen网关设备，该网关设备可以是CANopen转DeviceNet、Profibus、Modbus或其它的设备。在CANopen网络中，我们也可把该网关设备作为一个从站设备或者是CANopen主站设备。</p>
<p><img src="/.com//CANopen_ComplexesNetwork.png" alt="CANopen_ComplexesNetwork"></p>
<center> 图x </center>






<p><strong>NMT网络管理</strong></p>
<p>为实现CANopen网络稳定可靠高效运行，需要对CANopen网络进行网络管理，NMT主机通过下发命令，来控制NMT从机进行有序工作，故每个CANopen协议栈中都具有NMT网络管理的功能。</p>
<ul>
<li>CANopen节点设备运行时存在六种状态：<ul>
<li>初始化<ul>
<li>节点上电后对功能部件包括CAN控制器进行初始化。</li>
</ul>
</li>
<li>应用层复位<ul>
<li>节点中的应用程序复位（开始），比如开关量输出、模拟量输出的初始值。</li>
</ul>
</li>
<li>会话层复位<ul>
<li>节点中的CANopen通讯复位（开始），从这个时刻起，此节点就可以进行CANopen通讯了。</li>
</ul>
</li>
<li>预操作状态<ul>
<li>节点的CANopen通讯处于操作就绪状态，此时此节点不能进行PDO通信，而可以进行SDO进行参数配置和NMT网络管理的操作。</li>
</ul>
</li>
<li>操作状态<ul>
<li>节点收到NMT主机发来的启动命令后，CANopen通讯被激活，PDO通信启动后，按照对象字典里面规定的规则进行传输，同样SDO也可以对节点进行数据传输和参数修改。</li>
</ul>
</li>
<li>停止状态<ul>
<li>节点收到NMT主机发来的停止命令后，节点的PDO通信被停止，但SDO和NMT网络管理依然可以对节点进行操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如下图x所示，上述六种状态中除了初始化状态外，都可以通过NMT主机发送NMT命令让CANopen网络中任意一个节点进行其他5种状态的切换。</p>
<p><img src="/.com//CANopenStatus.png" alt="CANopen-status"></p>
<center> 图x </center>






<h2 id="CANopenNode简介"><a href="#CANopenNode简介" class="headerlink" title="CANopenNode简介"></a>CANopenNode简介</h2><p>CANopenNode是一款免费和开源的CANopen协议栈，使用用ANSI C语言以面向对象的方式编写的。它可以在不同的微控制器上运行，作为独立的应用程序或与RTOS一起运行。</p>
<p>变量（通信、设备、自定义）被收集在CANopen对象字典中，并且可以以两种方式修改：C源代码和CANopen网络。</p>
<p>CANopenNode的主页是位于：<a target="_blank" rel="noopener" href="https://github.com/CANopenNode/CANopenNode%E3%80%82">https://github.com/CANopenNode/CANopenNode。</a></p>
<h3 id="CANopenNode-vs-CAN-Festival"><a href="#CANopenNode-vs-CAN-Festival" class="headerlink" title="CANopenNode vs CAN Festival"></a>CANopenNode vs CAN Festival</h3><table>
<thead>
<tr>
<th>Feature</th>
<th>CANopenNode</th>
<th>CANFestival</th>
</tr>
</thead>
<tbody><tr>
<td>License</td>
<td>Apache v2.0</td>
<td>LGPLv2</td>
</tr>
<tr>
<td>NMT master &#x2F; slave</td>
<td>✓ &#x2F; ✓</td>
<td>✓ &#x2F; ✓</td>
</tr>
<tr>
<td>SDO client &#x2F; server</td>
<td>✓ &#x2F; ✓</td>
<td>✓ &#x2F; ✓</td>
</tr>
<tr>
<td>PDO</td>
<td>✓ &#x2F; ✓</td>
<td>✓ &#x2F; ✓</td>
</tr>
<tr>
<td>紧急报文</td>
<td>✓ &#x2F; ✓</td>
<td>✓ &#x2F; ✓</td>
</tr>
<tr>
<td>LLS</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Non-volatile storage support</td>
<td>×</td>
<td>✓</td>
</tr>
</tbody></table>
<p>CANFestival和CANopenNode都是用于在嵌入式系统上实现CANopen协议通信的开源软件协议栈。需要注意的是它们使用了不同的开放程度的开源协议。CANFestival使用LGPLv2开源协议。这意味着CANFestival的源代码是免费提供的，任何人都可以使用、修改和分发，只要任何衍生作品使用相同的GPL许可证。如果一个公司在产品中使用CANFestival，他们也必须按照同样的LGPLv2开源协议提供其产品的源代码。CANopenNode使用 Apache v2.0开源协议。这是一个自由度比LGPLv2更为开发的一个开源协议，允许在使用软件方面有更大的灵活性。任何人都可以使用、修改和发布CANopenNode，甚至用于商业目的，而不需要发布其衍生作品的源代码。</p>
<h3 id="获取CANopenNode源码"><a href="#获取CANopenNode源码" class="headerlink" title="获取CANopenNode源码"></a>获取CANopenNode源码</h3><p>选择 CANopenNode v1.3，该版本为CANopenNode官方验证发布版本，获取源码链接如下：<a target="_blank" rel="noopener" href="https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3%E3%80%82">https://github.com/CANopenNode/CANopenNode/releases/tag/v1.3。</a></p>
<h3 id="CANopenNode-功能特性"><a href="#CANopenNode-功能特性" class="headerlink" title="CANopenNode 功能特性"></a>CANopenNode 功能特性</h3><ul>
<li>支持启动、停止、重启设备的NMT从机和简单的NMT主机。</li>
<li>支持基于生产者消费者模型的心跳机制用于错误控制。</li>
<li>支持用于快速交换过程变量的PDO链接和动态映射。</li>
<li>支持SDO加速、分段和块状传输，用于对所有参数的服务访问以及SDO主机。</li>
<li>支持紧急报文。</li>
<li>支持基于生产者消费者模型的同步机制。</li>
<li>支持时间协议(生产者消费者模式)。</li>
<li>支持非易失性存储（掉电保存）。</li>
<li>支持LSS主机和从机, LSS 快速扫描。</li>
</ul>
<p>如CANopenNode官方README文档给出的那样，CANopenNode分为三个线程进行运行，分别为：</p>
<ul>
<li>主线程<ul>
<li>负责处理大部分协议栈相关函数。</li>
</ul>
</li>
<li>定时中断线程<ul>
<li>1ms执行一次，负责处理和时间相关的任务。</li>
</ul>
</li>
<li>CAN接收线程<ul>
<li>当接收到CAN帧时进入到这里并处理。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">                            -----------------------</span><br><span class="line">                           |     Program start     |</span><br><span class="line">                            -----------------------</span><br><span class="line">                                       |</span><br><span class="line">                            -----------------------</span><br><span class="line">                           |     CANopen init      |</span><br><span class="line">                            -----------------------</span><br><span class="line">                                       |</span><br><span class="line">                            -----------------------</span><br><span class="line">                           |     Start threads     |</span><br><span class="line">                            -----------------------</span><br><span class="line">                                 |     |     |</span><br><span class="line">             --------------------      |      --------------------</span><br><span class="line">            |                          |                          |</span><br><span class="line"> -----------------------    -----------------------    -----------------------</span><br><span class="line">| CAN receive thread    |  | Timer interval thread |  | Mainline thread       |</span><br><span class="line">|                       |  |                       |  |                       |</span><br><span class="line">| - Fast response.      |  | - Realtime thread with|  | - Processing of time  |</span><br><span class="line">| - Detect CAN ID.      |  |   constant interval,  |  |   consuming tasks     |</span><br><span class="line">| - Partially process   |  |   typically 1ms.      |  |   in CANopen objects: |</span><br><span class="line">|   messages and copy   |  | - Network synchronized|  |    - SDO server,      |</span><br><span class="line">|   data to target      |  | - Copy inputs (RPDOs, |  |    - Emergency,       |</span><br><span class="line">|   CANopen objects.    |  |   HW) to Object Dict. |  |    - Network state,   |</span><br><span class="line">|                       |  | - May call application|  |    - Heartbeat.       |</span><br><span class="line">|                       |  |   for some processing.|  | - May cyclically call |</span><br><span class="line">|                       |  | - Copy variables from |  |   application code.   |</span><br><span class="line">|                       |  |   Object Dictionary to|  |                       |</span><br><span class="line">|                       |  |   outputs (TPDOs, HW).|  |                       |</span><br><span class="line"> -----------------------    -----------------------    -----------------------</span><br><span class="line"></span><br><span class="line">              -----------------------</span><br><span class="line">             | SDO client (optional) |</span><br><span class="line">             |                       |</span><br><span class="line">             | - Can be called by    |</span><br><span class="line">             |   external application|</span><br><span class="line">             | - Can read or write   |</span><br><span class="line">             |   any variable from   |</span><br><span class="line">             |   Object Dictionary   |</span><br><span class="line">             |   from any node in the|</span><br><span class="line">             |   CANopen network.    |</span><br><span class="line">              -----------------------</span><br><span class="line"></span><br><span class="line">              -----------------------</span><br><span class="line">             | LSS client (optional) |</span><br><span class="line">             |                       |</span><br><span class="line">             | - Can be called by    |</span><br><span class="line">             |   external application|</span><br><span class="line">             | - Can do LSS requests |</span><br><span class="line">             | - Can request node    |</span><br><span class="line">             |   enumeration         |</span><br><span class="line">              -----------------------</span><br></pre></td></tr></table></figure>

<h3 id="CANopenNode-Basic-API-List"><a href="#CANopenNode-Basic-API-List" class="headerlink" title="CANopenNode  Basic  API  List"></a>CANopenNode  Basic  API  List</h3><p>initialize CANopen</p>
<ul>
<li>CO_ReturnError_t CO_init(void *CANdriverState, uint8_t nodeId, uint16_t bitRate)<ul>
<li>Initialize CANopen stack. Function must be called in the communication reset section.</li>
</ul>
</li>
</ul>
<p> Start CAN</p>
<ul>
<li>void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule)<ul>
<li>Request CAN normal (opearational) mode</li>
</ul>
</li>
</ul>
<p>CANopen process</p>
<ul>
<li>CO_NMT_reset_cmd_t CO_process(CO_t          *co, uint16_t timeDifference_ms, uint16_t *timerNext_ms)<ul>
<li>Process CANopen objects. Function must be called cyclically. It processes all “asynchronous” CANopen objects.</li>
</ul>
</li>
</ul>
<p>Process Sync</p>
<ul>
<li>bool_t CO_process_SYNC( CO_t          *co, uint32_t         timeDifference_us)<ul>
<li>Process CANopen SYNC objects. Function must be called cyclically from real time thread with constant interval (1ms typically). It processes SYNC CANopen objects.</li>
</ul>
</li>
</ul>
<p>Read inputs</p>
<ul>
<li>void CO_process_RPDO(CO_t          *co, bool_t          syncWas)<ul>
<li>Process CANopen RPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes receive PDO CANopen objects.</li>
</ul>
</li>
</ul>
<p>Write outputs</p>
<ul>
<li>void CO_process_TPDO(CO_t          *co, bool_t          syncWas, uint32_t         timeDifference_us)<ul>
<li>Process CANopen TPDO objects. Function must be called cyclically from real time thread with constant. interval (1ms typically). It processes transmit PDO CANopen objects.</li>
</ul>
</li>
</ul>
<p>CAN interrupt function</p>
<ul>
<li>void CO_CANinterrupt(CO_CANmodule_t *CANmodule)<ul>
<li>Receives and transmits CAN messages. Function must be called directly from high priority CAN interrupt.</li>
</ul>
</li>
</ul>
<h2 id="基于FlexCAN移植CANopenNode"><a href="#基于FlexCAN移植CANopenNode" class="headerlink" title="基于FlexCAN移植CANopenNode"></a>基于FlexCAN移植CANopenNode</h2><h3 id="CANopenNode软件包的源文件"><a href="#CANopenNode软件包的源文件" class="headerlink" title="CANopenNode软件包的源文件"></a>CANopenNode软件包的源文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">CANopenNode-1.3:</span><br><span class="line">│  .clang-format</span><br><span class="line">│  .gitignore</span><br><span class="line">│  CANopen.c</span><br><span class="line">│  CANopen.h</span><br><span class="line">│  codingStyle</span><br><span class="line">│  CO_driver.h</span><br><span class="line">│  CO_types.h</span><br><span class="line">│  Doxyfile</span><br><span class="line">│  LICENSE</span><br><span class="line">│  LICENSE.old</span><br><span class="line">│  Makefile</span><br><span class="line">│  README.md</span><br><span class="line">│</span><br><span class="line">├─example</span><br><span class="line">│  │  application.c</span><br><span class="line">│  │  application.h</span><br><span class="line">│  │  CO_OD.c</span><br><span class="line">│  │  CO_OD.h</span><br><span class="line">│  │  IO.eds</span><br><span class="line">│  │  IO.html</span><br><span class="line">│  │  main.c</span><br><span class="line">│  │  _project.html</span><br><span class="line">│  │  _project.xml</span><br><span class="line">│  │</span><br><span class="line">│  └─CO_OD_with_trace</span><br><span class="line">│          CO_OD.c</span><br><span class="line">│          CO_OD.h</span><br><span class="line">│</span><br><span class="line">└─stack</span><br><span class="line">    │  CO_Emergency.c</span><br><span class="line">    │  CO_Emergency.h</span><br><span class="line">    │  CO_HBconsumer.c</span><br><span class="line">    │  CO_HBconsumer.h</span><br><span class="line">    │  CO_LSS.h</span><br><span class="line">    │  CO_LSSmaster.c</span><br><span class="line">    │  CO_LSSmaster.h</span><br><span class="line">    │  CO_LSSslave.c</span><br><span class="line">    │  CO_LSSslave.h</span><br><span class="line">    │  CO_NMT_Heartbeat.c</span><br><span class="line">    │  CO_NMT_Heartbeat.h</span><br><span class="line">    │  CO_PDO.c</span><br><span class="line">    │  CO_PDO.h</span><br><span class="line">    │  CO_SDO.c</span><br><span class="line">    │  CO_SDO.h</span><br><span class="line">    │  CO_SDOmaster.c</span><br><span class="line">    │  CO_SDOmaster.h</span><br><span class="line">    │  CO_SYNC.c</span><br><span class="line">    │  CO_SYNC.h</span><br><span class="line">    │  CO_TIME.c</span><br><span class="line">    │  CO_TIME.h</span><br><span class="line">    │  CO_trace.c</span><br><span class="line">    │  CO_trace.h</span><br><span class="line">    │  crc16-ccitt.c</span><br><span class="line">    │  crc16-ccitt.h</span><br><span class="line">    │</span><br><span class="line">    ├─drvTemplate</span><br><span class="line">    │      CO_driver.c</span><br><span class="line">    │      CO_driver_target.h</span><br><span class="line">    │      eeprom.c</span><br><span class="line">    │      eeprom.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：上述仅包含移植用到的文件。</p>
<h3 id="CANopenNode的移植方法"><a href="#CANopenNode的移植方法" class="headerlink" title="CANopenNode的移植方法"></a>CANopenNode的移植方法</h3><p>CANopenNode移植中涉及到三个文件需要修改：</p>
<ul>
<li>CANopenNode-1.3&#x2F;example&#x2F;main.c 文件。</li>
<li>CANopenNode-1.3&#x2F;stack&#x2F;drvTemplate&#x2F;CO_driver.c 文件。</li>
<li>CANopenNode-1.3&#x2F;stack&#x2F;&#x2F;drvTemplate&#x2F;CO_driver_target.h 文件。</li>
</ul>
<p>其中：</p>
<ul>
<li><p>在 mian.c 文件中实现 tmrTask_thread() 函数</p>
<ul>
<li>通加载进入1ms 定时中断服务函数进行 1ms 定时的信息同步。</li>
</ul>
</li>
<li><p>在 CO_driver.c 文件中实现 CO_CANmodule_init() 函数</p>
<ul>
<li>用于对 MCU 中的 CAN 模块进行初始，并配置CAN报文的收发参数以及开启 flexcan 中断。</li>
</ul>
</li>
<li><p>在 CO_driver.C 文件中实现 CO_CANinterrupt() 函数</p>
<ul>
<li>用于实现接收和发送CAN信息。该功能从高优先级的CAN中断中直接调用。</li>
</ul>
</li>
<li><p>在 CO_driver.C 文件中实现 CO_CANverifyErrorst() 函数</p>
<ul>
<li>用于对 CAN 总线进行错误检测和上报。</li>
</ul>
</li>
</ul>
<h3 id="基于FlexCAN外设移植CANopenNode"><a href="#基于FlexCAN外设移植CANopenNode" class="headerlink" title="基于FlexCAN外设移植CANopenNode"></a>基于FlexCAN外设移植CANopenNode</h3><p>下面我们将以MM32G5330微控制器上集成的FlexCAN为例，实现对CANopenNode v1.3的移植过程。</p>
<p>首先在灵动官网下载基于Mini-G5330开发板的FlexCAN_Interrupt样例工程，并在MM32G5330的根目录文件夹下创建CANopenNode文件夹。将CANopenNode v1.3软件包中包含的下列文件无需修改，原封不动地复制到新建的 CANopenNode 文件夹中。</p>
<pre><code>./CANopen.c&amp;h
./CO_types.h
./stack/CO_Emergency.c&amp;h
./stack/CO_HBconsumer.c&amp;h
./stack/CO_LSS.h
./stack/CO_LSSmaster.c&amp;h
./stack/CO_LSSslave.c&amp;h
./stack/CO_NMT_Heartbeat.c&amp;h
./stack/CO_PDO.c&amp;h
./stack/CO_SDO.c&amp;h
./stack/CO_SDOmaster.c&amp;h
./stack/CO_SYNC.c&amp;h
./stack/CO_TIME.c&amp;h
./stack/CO_trace.c&amp;h
./stack/crc16-ccitt.c&amp;h
</code></pre>
<p>如下图x所示：</p>
<p><img src="/.com//components_canopen.png" alt="image-20231213182716874"> </p>
<center>图 x </center>

<p>接着将CANopenNode源码中提供的example文件夹的结构如下图x所示，其中CO_OD.c&#x2F;h是 CANopen中使用到的对象字典， 我们将这两个文件复制到 MM32G5330样例工程的board文件夹下。main.c是 CANopenNode的主程序文件，我们将将原有的main.c文件进行替换。</p>
<p><img src="/.com//CANopenNode-example.png" alt="image-20230130180116311"></p>
<center> 图 x </center>




<p>最后将如图x所示的位于CANopenNode-1.3&#x2F;stack&#x2F;drvTemplate文件夹下的CO_driver.c及CO_driver_target.h这两个文件复制到样例工程的文件夹下。</p>
<p><img src="/.com//CANopenNode-drvTemp.png" alt="image-20230131094145961"></p>
<center> 图 x </center>




<p>由于本次移植是基于裸机移植，故按照CANopenNode的设计将Mainline线程放入while(1)中，CAN接收线程放入flexcan的中断服务程序中，定时线程放在一个1ms的定时中断服务程序中。</p>
<p><strong>在 <code>main.c</code> 文件中配置定时器</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the timer. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_tim_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_InitTypeDef        NVIC_InitStruct;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;</span><br><span class="line"></span><br><span class="line">    RCC_ClocksTypeDef RCC_Clocks;</span><br><span class="line"></span><br><span class="line">    RCC_GetClocksFreq(&amp;RCC_Clocks);</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2ENR_TIM1, ENABLE);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseStructInit(&amp;TIM_TimeBaseInitStruct);</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Prescaler         = (RCC_Clocks.PCLK2_Frequency / APP_TIM_UPDATE_STEP - <span class="number">1</span>);</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_CounterMode       = TIM_COUNTERMODE_UP;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_Period            = (APP_TIM_UPDATE_PERIOD - <span class="number">1</span>);</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_ClockDivision     = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStruct.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseInitStruct);</span><br><span class="line"></span><br><span class="line">    TIM_ClearFlag(TIM1, TIM_IT_UPDATE);</span><br><span class="line">    TIM_ITConfig(TIM1, TIM_IT_UPDATE, ENABLE);</span><br><span class="line"></span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannel = TIM1_UP_IRQn;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">0</span>;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM1_UP_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE);</span><br><span class="line">    tmrTask_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 <code>main.c</code> 文件中实现定时线程任务处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* timer thread executes in constant intervals ********************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tmrTask_thread</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    INCREMENT_1MS(CO_timer1ms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CO-&gt;CANmodule[<span class="number">0</span>]-&gt;CANnormal) &#123;</span><br><span class="line">        <span class="type">bool_t</span> syncWas;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process Sync */</span></span><br><span class="line">        syncWas = CO_process_SYNC(CO, TMR_TASK_INTERVAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read inputs */</span></span><br><span class="line">        CO_process_RPDO(CO, syncWas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Further I/O or nonblocking application code may go here. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write outputs */</span></span><br><span class="line">        CO_process_TPDO(CO, syncWas, TMR_TASK_INTERVAL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* verify timer overflow */</span></span><br><span class="line">        <span class="keyword">if</span>((TIM_GetITStatus(TIM1, TIM_IT_UPDATE) &amp; TIM_IT_UPDATE) != <span class="number">0u</span>) &#123;</span><br><span class="line">            CO_errorReport(CO-&gt;em, CO_EM_ISR_TIMER_OVERFLOW, CO_EMC_SOFTWARE_INTERNAL, <span class="number">0u</span>);</span><br><span class="line">            TIM_ClearITPendingBit(TIM1, TIM_IT_UPDATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 <code>main.c</code> 文件中实现 FlexCAN 的中断服务函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CAN interrupt function *****************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLEXCAN_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FLEXCAN_TransferHandleIRQ(FLEXCAN, &amp;FlexCAN_Handle);</span><br><span class="line">    CO_CANinterrupt(CO-&gt;CANmodule[<span class="number">0</span>]);</span><br><span class="line">    __DSB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 <code>CO_driver.c</code> 文件中实现FlexCAN模块初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FlexCAN_Configure</span><span class="params">(<span class="type">uint32_t</span> can_bitrate)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">    RCC_ClocksTypeDef RCC_Clocks;</span><br><span class="line"></span><br><span class="line">    <span class="type">flexcan_config_t</span>       FlexCAN_ConfigStruct;</span><br><span class="line">    <span class="type">flexcan_rx_mb_config_t</span> FlexCAN_RxMB_ConfigStruct;</span><br><span class="line"></span><br><span class="line">    RCC_GetClocksFreq(&amp;RCC_Clocks);</span><br><span class="line"></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1PERIPH_FLEXCAN, ENABLE);</span><br><span class="line">    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE11, GPIO_AF_9);</span><br><span class="line">    GPIO_PinAFConfig(GPIOA, GPIO_PINSOURCE12, GPIO_AF_9);</span><br><span class="line"></span><br><span class="line">    GPIO_StructInit(&amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin   = GPIO_PIN_11;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode  = GPIO_MODE_FLOATING;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_StructInit(&amp;GPIO_InitStruct);</span><br><span class="line">    GPIO_InitStruct.GPIO_Pin   = GPIO_PIN_12;</span><br><span class="line">    GPIO_InitStruct.GPIO_Speed = GPIO_SPEED_HIGH;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode  = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannel = FLEXCAN_IRQn;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">0</span>;</span><br><span class="line">    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line">    FLEXCAN_GetDefaultConfig(&amp;FlexCAN_ConfigStruct);</span><br><span class="line">    FlexCAN_ConfigStruct.baudRate             = can_bitrate*<span class="number">1000</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.clkSrc               = Enum_Flexcan_ClkSrc1;</span><br><span class="line">    FlexCAN_ConfigStruct.enableLoopBack       = <span class="literal">false</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.disableSelfReception = <span class="literal">true</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.enableIndividMask    = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1    <span class="comment">/* Baudrate calculate by automatically */</span></span></span><br><span class="line">    FLEXCAN_CalculateImprovedTimingValues(FlexCAN_ConfigStruct.baudRate, RCC_Clocks.PCLK1_Frequency, &amp;FlexCAN_ConfigStruct.timingConfig);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* You can modify the parameters yourself */</span></span></span><br><span class="line">    FlexCAN_ConfigStruct.timingConfig.preDivider = <span class="number">23</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.timingConfig.propSeg    = <span class="number">6</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.timingConfig.phaseSeg1  = <span class="number">3</span>;</span><br><span class="line">    FlexCAN_ConfigStruct.timingConfig.phaseSeg2  = <span class="number">3</span>;    </span><br><span class="line">    FlexCAN_ConfigStruct.timingConfig.rJumpwidth = <span class="number">3</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    FLEXCAN_Init(FLEXCAN, &amp;FlexCAN_ConfigStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set Tx MB_2. */</span></span><br><span class="line">    FLEXCAN_TxMbConfig(FLEXCAN, BOARD_FLEXCAN_TX_MB_CH, ENABLE);</span><br><span class="line">    FLEXCAN_TransferCreateHandle(FLEXCAN, &amp;FlexCAN_Handle, FlexCAN_Transfer_Callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set Rx MB_0. */</span></span><br><span class="line">    FlexCAN_RxMB_ConfigStruct.id     = FLEXCAN_ID_STD(<span class="number">0x222</span>);</span><br><span class="line">    FlexCAN_RxMB_ConfigStruct.format = Enum_Flexcan_FrameFormatStandard;</span><br><span class="line">    FlexCAN_RxMB_ConfigStruct.type   = Enum_Flexcan_FrameTypeData;</span><br><span class="line">    FLEXCAN_RxMbConfig(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, &amp;FlexCAN_RxMB_ConfigStruct, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set Rx Individual Mask. */</span></span><br><span class="line">    FLEXCAN_SetRxIndividualMask(FLEXCAN, BOARD_FLEXCAN_RX_MB_CH, FLEXCAN_RX_MB_STD_MASK(<span class="number">0x000</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    FlexCAN_MB0_FrameStruct.length = (<span class="type">uint8_t</span>)(<span class="number">8</span>);</span><br><span class="line">    FlexCAN_MB0_FrameStruct.type   = (<span class="type">uint8_t</span>)Enum_Flexcan_FrameTypeData;</span><br><span class="line">    FlexCAN_MB0_FrameStruct.format = (<span class="type">uint8_t</span>)Enum_Flexcan_FrameFormatStandard;</span><br><span class="line">    FlexCAN_MB0_FrameStruct.id     = FLEXCAN_ID_STD(<span class="number">0x222</span>);</span><br><span class="line"></span><br><span class="line">    FlexCAN_MB0_TransferStruct.mbIdx = BOARD_FLEXCAN_RX_MB_CH;</span><br><span class="line">    FlexCAN_MB0_TransferStruct.frame = &amp;FlexCAN_MB0_FrameStruct;</span><br><span class="line">    FLEXCAN_TransferReceiveNonBlocking(FLEXCAN, &amp;FlexCAN_Handle, &amp;FlexCAN_MB0_TransferStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line">CO_ReturnError_t <span class="title function_">CO_CANmodule_init</span><span class="params">(</span></span><br><span class="line"><span class="params">        CO_CANmodule_t         *CANmodule,</span></span><br><span class="line"><span class="params">        <span class="type">void</span>                   *CANdriverState,</span></span><br><span class="line"><span class="params">        CO_CANrx_t              rxArray[],</span></span><br><span class="line"><span class="params">        <span class="type">uint16_t</span>                rxSize,</span></span><br><span class="line"><span class="params">        CO_CANtx_t              txArray[],</span></span><br><span class="line"><span class="params">        <span class="type">uint16_t</span>                txSize,</span></span><br><span class="line"><span class="params">        <span class="type">uint16_t</span>                CANbitRate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* verify arguments */</span></span><br><span class="line">    <span class="keyword">if</span>(CANmodule==<span class="literal">NULL</span> || rxArray==<span class="literal">NULL</span> || txArray==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> CO_ERROR_ILLEGAL_ARGUMENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure object variables */</span></span><br><span class="line">    CANmodule-&gt;CANdriverState = CANdriverState;</span><br><span class="line">    CANmodule-&gt;rxArray = rxArray;</span><br><span class="line">    CANmodule-&gt;rxSize = rxSize;</span><br><span class="line">    CANmodule-&gt;txArray = txArray;</span><br><span class="line">    CANmodule-&gt;txSize = txSize;</span><br><span class="line">    CANmodule-&gt;CANnormal = <span class="literal">false</span>;</span><br><span class="line">    CANmodule-&gt;useCANrxFilters = <span class="literal">false</span>;<span class="comment">/* microcontroller dependent */</span></span><br><span class="line">    CANmodule-&gt;bufferInhibitFlag = <span class="literal">false</span>;</span><br><span class="line">    CANmodule-&gt;firstCANtxMessage = <span class="literal">true</span>;</span><br><span class="line">    CANmodule-&gt;CANtxCount = <span class="number">0U</span>;</span><br><span class="line">    CANmodule-&gt;errOld = <span class="number">0U</span>;</span><br><span class="line">    CANmodule-&gt;em = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0U</span>; i&lt;rxSize; i++)&#123;</span><br><span class="line">        rxArray[i].ident = <span class="number">0U</span>;</span><br><span class="line">        rxArray[i].mask = <span class="number">0xFFFF</span>U;</span><br><span class="line">        rxArray[i].object = <span class="literal">NULL</span>;</span><br><span class="line">        rxArray[i].pFunct = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0U</span>; i&lt;txSize; i++)&#123;</span><br><span class="line">        txArray[i].bufferFull = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FlexCAN_Configure(CANbitRate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CO_ERROR_NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>CO_driver.c</code> 文件中实现FlexCAN的报文收发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a message frame. */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">flexcan_tx</span><span class="params">(CO_CANtx_t *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> status = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">flexcan_frame_t</span>       FlexCAN_FrameStruct;</span><br><span class="line">    <span class="type">flexcan_mb_transfer_t</span> FlexCAN_MB_TransferStruct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!buffer-&gt;rtr)</span><br><span class="line">    &#123;</span><br><span class="line">        FlexCAN_FrameStruct.type = (<span class="type">uint8_t</span>)Enum_Flexcan_FrameTypeData; <span class="comment">/* Data frame type. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FlexCAN_FrameStruct.type = (<span class="type">uint8_t</span>)Enum_Flexcan_FrameTypeRemote; <span class="comment">/* Remote frame type. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FlexCAN_FrameStruct.length = (<span class="type">uint8_t</span>)buffer-&gt;DLC;</span><br><span class="line">    FlexCAN_FrameStruct.format = (<span class="type">uint8_t</span>)Enum_Flexcan_FrameFormatStandard;</span><br><span class="line">    FlexCAN_FrameStruct.id     = FLEXCAN_ID_STD(buffer-&gt;ident); <span class="comment">/* Indicated ID number. */</span></span><br><span class="line"></span><br><span class="line">    FlexCAN_FrameStruct.dataByte0 = buffer-&gt;data[<span class="number">0</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte1 = buffer-&gt;data[<span class="number">1</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte2 = buffer-&gt;data[<span class="number">2</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte3 = buffer-&gt;data[<span class="number">3</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte4 = buffer-&gt;data[<span class="number">4</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte5 = buffer-&gt;data[<span class="number">5</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte6 = buffer-&gt;data[<span class="number">6</span>];</span><br><span class="line">    FlexCAN_FrameStruct.dataByte7 = buffer-&gt;data[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    FlexCAN_MB_TransferStruct.mbIdx = <span class="number">2</span>;</span><br><span class="line">    FlexCAN_MB_TransferStruct.frame = &amp;FlexCAN_FrameStruct;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Status_Flexcan_Success == FLEXCAN_TransferSendNonBlocking(FLEXCAN, &amp;FlexCAN_Handle, &amp;FlexCAN_MB_TransferStruct))</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line">CO_ReturnError_t <span class="title function_">CO_CANsend</span><span class="params">(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer)</span>&#123;</span><br><span class="line">    CO_ReturnError_t err = CO_ERROR_NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify overflow */</span></span><br><span class="line">    <span class="keyword">if</span>(buffer-&gt;bufferFull)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!CANmodule-&gt;firstCANtxMessage)&#123;</span><br><span class="line">            <span class="comment">/* don&#x27;t set error, if bootup message is still on buffers */</span></span><br><span class="line">            CO_errorReport((CO_EM_t*)CANmodule-&gt;em, CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN, buffer-&gt;ident);</span><br><span class="line">        &#125;</span><br><span class="line">        err = CO_ERROR_TX_OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CO_LOCK_CAN_SEND();</span><br><span class="line">    <span class="type">bool</span> tx_mb_status = flexcan_tx(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tx_mb_status == <span class="literal">true</span>)&#123;</span><br><span class="line">        CANmodule-&gt;bufferInhibitFlag = buffer-&gt;syncFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* if no buffer is free, message will be sent by interrupt */</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        buffer-&gt;bufferFull = <span class="literal">true</span>;</span><br><span class="line">        CANmodule-&gt;CANtxCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    CO_UNLOCK_CAN_SEND();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CO_CANinterrupt</span><span class="params">(CO_CANmodule_t *CANmodule)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> status = FLEXCAN-&gt;IFLAG1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (status &amp; (BOARD_FLEXCAN_RX_MB_STATUS)) || (FlexCAN_MB0_RxCompleteFlag))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* receive interrupt */</span></span><br><span class="line">        CO_CANrxMsg_t *rcvMsg;      <span class="comment">/* pointer to received message in CAN module */</span></span><br><span class="line">        CO_CANrxMsg_t rcvMsgBuff;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint16_t</span> index;             <span class="comment">/* index of received message */</span></span><br><span class="line">        <span class="type">uint32_t</span> rcvMsgIdent;       <span class="comment">/* identifier of the received message */</span></span><br><span class="line">        CO_CANrx_t *buffer = <span class="literal">NULL</span>;  <span class="comment">/* receive message buffer from CO_CANmodule_t object. */</span></span><br><span class="line">        <span class="type">bool_t</span> msgMatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get message from module here */</span></span><br><span class="line">        rcvMsg = &amp;rcvMsgBuff;</span><br><span class="line"></span><br><span class="line">        rcvMsg-&gt;ident   = (FlexCAN_MBTemp_FrameStruct.id&gt;&gt; CAN_ID_STD_SHIFT)&amp;<span class="number">0x7FF</span>;</span><br><span class="line">        rcvMsg-&gt;DLC     = FlexCAN_MBTemp_FrameStruct.length;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">0</span>] = FlexCAN_MBTemp_FrameStruct.dataByte0;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">1</span>] = FlexCAN_MBTemp_FrameStruct.dataByte1;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">2</span>] = FlexCAN_MBTemp_FrameStruct.dataByte2;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">3</span>] = FlexCAN_MBTemp_FrameStruct.dataByte3;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">4</span>] = FlexCAN_MBTemp_FrameStruct.dataByte4;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">5</span>] = FlexCAN_MBTemp_FrameStruct.dataByte5;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">6</span>] = FlexCAN_MBTemp_FrameStruct.dataByte6;</span><br><span class="line">        rcvMsg-&gt;data[<span class="number">7</span>] = FlexCAN_MBTemp_FrameStruct.dataByte7;</span><br><span class="line"></span><br><span class="line">        rcvMsgIdent = rcvMsg-&gt;ident;</span><br><span class="line"></span><br><span class="line">        FlexCAN_MB0_RxCompleteFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CAN module filters are not used, message with any standard 11-bit identifier */</span></span><br><span class="line">        <span class="comment">/* has been received. Search rxArray form CANmodule for the same CAN-ID. */</span></span><br><span class="line">        buffer = &amp;CANmodule-&gt;rxArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(index = CANmodule-&gt;rxSize; index &gt; <span class="number">0U</span>; index--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((rcvMsgIdent ^ buffer-&gt;ident) &amp; buffer-&gt;mask) == <span class="number">0U</span>)&#123;</span><br><span class="line">                msgMatched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call specific function, which will process the message */</span></span><br><span class="line">        <span class="keyword">if</span>(msgMatched &amp;&amp; (buffer != <span class="literal">NULL</span>) &amp;&amp; (buffer-&gt;pFunct != <span class="literal">NULL</span>))&#123;</span><br><span class="line">            buffer-&gt;pFunct(buffer-&gt;object, rcvMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clear interrupt flag */</span></span><br><span class="line">        FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_RX_MB_STATUS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != (status &amp; BOARD_FLEXCAN_TX_MB_STATUS))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Clear interrupt flag */</span></span><br><span class="line">        FLEXCAN_ClearMbStatusFlags(FLEXCAN, BOARD_FLEXCAN_TX_MB_STATUS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First CAN message (bootup) was sent successfully */</span></span><br><span class="line">        CANmodule-&gt;firstCANtxMessage = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* clear flag from previous message */</span></span><br><span class="line">        CANmodule-&gt;bufferInhibitFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* Are there any new messages waiting to be send */</span></span><br><span class="line">        <span class="keyword">if</span>(CANmodule-&gt;CANtxCount &gt; <span class="number">0U</span>)&#123;</span><br><span class="line">            <span class="type">uint16_t</span> i;             <span class="comment">/* index of transmitting message */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* first buffer */</span></span><br><span class="line">            CO_CANtx_t *buffer = &amp;CANmodule-&gt;txArray[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">/* search through whole array of pointers to transmit message buffers. */</span></span><br><span class="line">            <span class="keyword">for</span>(i = CANmodule-&gt;txSize; i &gt; <span class="number">0U</span>; i--)&#123;</span><br><span class="line">                <span class="comment">/* if message buffer is full, send it. */</span></span><br><span class="line">                <span class="keyword">if</span>(buffer-&gt;bufferFull)&#123;</span><br><span class="line">                    buffer-&gt;bufferFull = <span class="literal">false</span>;</span><br><span class="line">                    CANmodule-&gt;CANtxCount--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Copy message to CAN buffer */</span></span><br><span class="line">                    CANmodule-&gt;bufferInhibitFlag = buffer-&gt;syncFlag;</span><br><span class="line">                    CO_CANsend(CANmodule, buffer);</span><br><span class="line">                    <span class="keyword">break</span>;                      <span class="comment">/* exit for loop */</span></span><br><span class="line">                &#125;</span><br><span class="line">                buffer++;</span><br><span class="line">            &#125;<span class="comment">/* end of for loop */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Clear counter if no more messages */</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0U</span>)&#123;</span><br><span class="line">                CANmodule-&gt;CANtxCount = <span class="number">0U</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* some other interrupt reason */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 <code>CO_driver.c</code> 文件中实现CAN总线错误检测</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CO_CANverifyErrors</span><span class="params">(CO_CANmodule_t *CANmodule)</span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> rxErrors, txErrors, overflow;</span><br><span class="line">    CO_EM_t* em = (CO_EM_t*)CANmodule-&gt;em;</span><br><span class="line">    <span class="type">uint32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get error counters from module. Id possible, function may use different way to</span></span><br><span class="line"><span class="comment">     * determine errors. */</span></span><br><span class="line">    rxErrors = (<span class="type">uint16_t</span>) ((FLEXCAN-&gt;ECR &amp; CAN_ECR_RXERRCNT_MASK) &gt;&gt; CAN_ECR_RXERRCNT_SHIFT);</span><br><span class="line">    txErrors = (<span class="type">uint16_t</span>) ((FLEXCAN-&gt;ECR &amp; CAN_ECR_TXERRCNT_MASK) &gt;&gt; CAN_ECR_TXERRCNT_SHIFT);</span><br><span class="line">    overflow = (<span class="type">uint16_t</span>) ((FLEXCAN-&gt;ESR1 &amp; CAN_ESR1_ERROVR_MASK) &gt;&gt; CAN_ESR1_ERROVR_SHIFT);</span><br><span class="line"></span><br><span class="line">    err = ((<span class="type">uint32_t</span>)txErrors &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)rxErrors &lt;&lt; <span class="number">8</span>) | overflow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CANmodule-&gt;errOld != err)&#123;</span><br><span class="line">        CANmodule-&gt;errOld = err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(txErrors &gt;= <span class="number">256U</span>)&#123;                               <span class="comment">/* bus off */</span></span><br><span class="line">            CO_errorReport(em, CO_EM_CAN_TX_BUS_OFF, CO_EMC_BUS_OFF_RECOVERED, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                                               <span class="comment">/* not bus off */</span></span><br><span class="line">            CO_errorReset(em, CO_EM_CAN_TX_BUS_OFF, err);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((rxErrors &gt;= <span class="number">96U</span>) || (txErrors &gt;= <span class="number">96U</span>))&#123;     <span class="comment">/* bus warning */</span></span><br><span class="line">                CO_errorReport(em, CO_EM_CAN_BUS_WARNING, CO_EMC_NO_ERROR, err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rxErrors &gt;= <span class="number">128U</span>)&#123;                           <span class="comment">/* RX bus passive */</span></span><br><span class="line">                CO_errorReport(em, CO_EM_CAN_RX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                CO_errorReset(em, CO_EM_CAN_RX_BUS_PASSIVE, err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(txErrors &gt;= <span class="number">128U</span>)&#123;                           <span class="comment">/* TX bus passive */</span></span><br><span class="line">                <span class="keyword">if</span>(!CANmodule-&gt;firstCANtxMessage)&#123;</span><br><span class="line">                    CO_errorReport(em, CO_EM_CAN_TX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">bool_t</span> isError = CO_isError(em, CO_EM_CAN_TX_BUS_PASSIVE);</span><br><span class="line">                <span class="keyword">if</span>(isError)&#123;</span><br><span class="line">                    CO_errorReset(em, CO_EM_CAN_TX_BUS_PASSIVE, err);</span><br><span class="line">                    CO_errorReset(em, CO_EM_CAN_TX_OVERFLOW, err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((rxErrors &lt; <span class="number">96U</span>) &amp;&amp; (txErrors &lt; <span class="number">96U</span>))&#123;       <span class="comment">/* no error */</span></span><br><span class="line">                CO_errorReset(em, CO_EM_CAN_BUS_WARNING, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(overflow != <span class="number">0U</span>)&#123;                                 <span class="comment">/* CAN RX bus overflow */</span></span><br><span class="line">            CO_errorReport(em, CO_EM_CAN_RXB_OVERFLOW, CO_EMC_CAN_OVERRUN, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述文件复制到对应的工程样例文件路径下，并将这些文件添加进工程编译文件列表中后，编译下载程序，CANopen节点上线向CAN网络发送CANopen节点上线报文，上位机收到一条如下报文：</p>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">70A</td>
<td align="left">1</td>
<td align="left">00</td>
</tr>
</tbody></table>
<p>之后该CANopen节点以 1000ms 的时间间隔向CAN网络发送节点心跳报文，上位机以1000ms的时间间隔收到如下报文：</p>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">70A</td>
<td align="left">1</td>
<td align="left">05</td>
</tr>
</tbody></table>
<p>如图x所示。</p>
<p><img src="/.com//PCAN-View.png" alt="image-20230220110237610"></p>
<center>图x </center>

<p>至此，可验证该CANopen节点设备成功启动并开始正常运行。</p>
<p>同时在灵动提供的样例中，也提供了一些移植好的CANopenNode样例工程，供大家验证测试：</p>
<ul>
<li><p>CANopen_Basic样例</p>
<ul>
<li>演示了CANopenNode的基本样例功能。</li>
</ul>
</li>
<li><p>CANopen_PDO_TPDO&amp;CANopen_PDO_RPDO样例</p>
<ul>
<li>演示了CANopen的TPDO与RPDO之间通信的样例。</li>
</ul>
</li>
<li><p>CANopen_SDO_Server&amp;CANopen_SDO_Client样例</p>
<ul>
<li>演示了CANopen的SDO Server与SDO Client之间通信的样例。</li>
</ul>
</li>
</ul>
<h2 id="调试与开发"><a href="#调试与开发" class="headerlink" title="调试与开发"></a>调试与开发</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>使用搭载了MM32G5330 MCU的开发板Mini-G5330 ，以CANopen_Basic样例工程为例，将开发板上的CAN收发器与PCAN相连接，并将PCAN与PC机通过USB相连接，在PC端（基于Win10操作系统）使用PCAN-View上位机进行CAN通信，如图x所示。 </p>
<p><img src="/.com//image-mcu&pc.png" alt="image-mcu&amp;pc"></p>
<center>图x MCU与PC机交互示意图 </center>


<p>这里我们使用了PCAN-USB，并使用了其官方的配套上位机PCAN-View。其PCAN-USB驱动下载链接为：(<a target="_blank" rel="noopener" href="https://peak-system.com.cn/driver/)%EF%BC%9BPCAN-View">https://peak-system.com.cn/driver/)；PCAN-View</a> 安装包下载链接为: (<a target="_blank" rel="noopener" href="https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip)%EF%BC%9BPCAN-View%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E8%A7%81%E5%A6%82%E4%B8%8B%E9%93%BE%E6%8E%A5">https://peak-system.com.cn/wp-content/uploads/2022/06/pcanview.zip)；PCAN-View使用说明见如下链接</a>: (<a target="_blank" rel="noopener" href="https://peak-system.com.cn/software/apsoftware/pcan-view/">https://peak-system.com.cn/software/apsoftware/pcan-view/</a>)</p>
<h3 id="上电调试"><a href="#上电调试" class="headerlink" title="上电调试"></a>上电调试</h3><p>将上述环境搭建好后，将MCU上电并复位，并通过PC端上位机PCAN-View测试如下指令，观察CANopen节点其对指令的响应，来判断该CANopen节点是否处于正常运行状态。</p>
<ul>
<li>将NODE-ID为0x0A的节点设置为 Stop 模式，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000</td>
<td align="left">2</td>
<td align="left">02 0A</td>
</tr>
</tbody></table>
<p>如下图x所示，可接收到如下报文：</p>
<p><img src="/.com//Stop-the-Node.png" alt="image-20230220172938551"></p>
<center> 图 x </center>


<ul>
<li>将NODE-ID为0x0A的节点设置为 Start 模式，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">000</td>
<td align="left">2</td>
<td align="left">01 0A</td>
</tr>
</tbody></table>
<p>如下图x所示，可接收到如下报文：</p>
<p><img src="/.com//Start-the-Node.png" alt="image-20230220181043270"></p>
<center> 图x </center>

<ul>
<li>将NODE-ID为0x0A的节点设置为Pre-operation模式，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th>CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td>70A</td>
<td align="left">2</td>
<td align="left">80 0A</td>
</tr>
</tbody></table>
<p>如下图x所示，该节点进入Pre-operation模式，可接收到如下报文：</p>
<p><img src="/.com//Preoperaion-the-Node.png" alt="image-20230220173143412"></p>
<center> 图 x </center>


<ul>
<li>将NODE-ID为0x0A节点复位，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">70A</td>
<td align="left">2</td>
<td align="left">81 0A</td>
</tr>
</tbody></table>
<p>如下图x所示，该节点被复位：</p>
<p><img src="/.com//Reset--the-Node.png" alt="image-20230220173338692"></p>
<center> 图 x </center>


<ul>
<li>将NODE-ID为0x0A节点的通信层复位，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">70A</td>
<td align="left">2</td>
<td align="left">82 0A</td>
</tr>
</tbody></table>
<p>如下图x所示，该节点通信层被复位，重新上线：</p>
<p><img src="/.com//Reset-commu-the-Node.png" alt="image-20230220181246407"></p>
<center> 图 x </center>


<ul>
<li>获取NODE-ID为0x0A节点的心跳发送间隔时间，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">60A</td>
<td align="left">8</td>
<td align="left">40 17 10 00 00 00 00 00</td>
</tr>
</tbody></table>
<p>如下图x所示，返回该节点当前心跳发送间隔时间为1000(0x03E8)ms：</p>
<p><img src="/.com//Get-heartbeat.png" alt="image-20230220174859554"></p>
<center> 图 x </center>


<ul>
<li>设置NODE-ID为0x0A节点的心跳发送间隔时间为500(0x01F4)ms，上位机PCAN-View发送如下指令：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">CAN-ID(hex)</th>
<th align="left">Length</th>
<th align="left">Data(hex)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">60A</td>
<td align="left">8</td>
<td align="left">2B 17 10 00 F4 01 00 00</td>
</tr>
</tbody></table>
<p>如下图x所示，该节点当前心跳发送间隔时间变为500ms：</p>
<p><img src="/.com//Set-heartbeat.png" alt="image-20230220175604643"></p>
<center> 图 x </center>




<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节讲解了CANopen的基本概念，并对CANopenNode开源协议栈进行了介绍，讲解了如何基于MM32G5330 MCU对CANopenNode协议栈进行移植，以及对移植后的CANopen_Basic样例进行基本指令响应功能的验证。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[CiA - CANopen] (<a target="_blank" rel="noopener" href="https://www.can-cia.org/canopen/">https://www.can-cia.org/canopen/</a>)</p>
<p>[CANopenNode] (<a target="_blank" rel="noopener" href="https://github.com/CANopenNode/CANopenNode">https://github.com/CANopenNode/CANopenNode</a>)</p>
<p>[CANopen_easy_begin] (<a target="_blank" rel="noopener" href="https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf">https://www.zlg.cn/data/upload/software/Can/CANopen_easy_begin.pdf</a>)</p>
<p>[CANopen Explained - A Simple Intro] (<a target="_blank" rel="noopener" href="https://www.csselectronics.com/pages/canopen-tutorial-simple-intro">https://www.csselectronics.com/pages/canopen-tutorial-simple-intro</a>)</p>
<p>[CANopen: The Ultimate Guide (2023) (autopi.io)] (<a target="_blank" rel="noopener" href="https://www.autopi.io/blog/canopen-simple-introduction-explained/">https://www.autopi.io/blog/canopen-simple-introduction-explained/</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/" data-id="clrfqdhmg0000nwv92ayheccw" data-title="从零开始移植CANopenNode协议栈" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CANopenNode/" rel="tag">CANopenNode</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DLwIP%E5%8D%8F%E8%AE%AE%E6%A0%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">从零开始移植LwIP协议栈</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CANopenNode/" rel="tag">CANopenNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LwIP/" rel="tag">LwIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TinyUSB/" rel="tag">TinyUSB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/USB/" rel="tag">USB</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CANopenNode/" style="font-size: 10px;">CANopenNode</a> <a href="/tags/LwIP/" style="font-size: 10px;">LwIP</a> <a href="/tags/TinyUSB/" style="font-size: 10px;">TinyUSB</a> <a href="/tags/USB/" style="font-size: 10px;">USB</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DCANopenNode%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植CANopenNode协议栈</a>
          </li>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DLwIP%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植LwIP协议栈</a>
          </li>
        
          <li>
            <a href="/2024/01/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%A7%BB%E6%A4%8DTinyUSB%E5%8D%8F%E8%AE%AE%E6%A0%88/">从零开始移植TinyUSB协议栈</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Allen Ma<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>